<!DOCTYPE html>
<html><head>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'>
<title>실시간 촬영 및 분석</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f0f2f5; color: #1f2937; line-height: 1.6; }
.container { max-width: 600px; margin: 1rem auto; background-color: #ffffff; border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.1); overflow: hidden; }
.header { background-color: #ffffff; padding: 1.25rem; border-bottom: 1px solid #e5e7eb; text-align: center; }
.header h1 { font-size: 1.5rem; font-weight: 600; color: #111827; }
.video-container { width: calc(100% - 2.5rem); margin: 1.25rem auto; position: relative; background-color: #111827; border-radius: 10px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.15); aspect-ratio: 4/3; }
#video-stream { width: 100%; height: 100%; object-fit: cover; display: block; }
.overlay-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
.info-panel { padding: 0 1.25rem 1.25rem; }
.info-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
.info-panel-header h2 { font-size: 1.125rem; font-weight: 600; color: #1f2937; }
#current-time { font-size: 0.875rem; color: #4b5563; }
#analysis-status, #analysis-result, .explanatory-text { text-align: center; margin-top: 0.75rem; font-size: 0.875rem; }
#analysis-status { color: #4b5563; min-height: 1.2em; }
.explanatory-text { color: #6b7280; }
.yolo-toggle { display: flex; align-items: center; justify-content: center; gap: 0.5rem; margin-top: 0.5rem; }
.yolo-toggle input { width: 1rem; height: 1rem; }
</style>
</head><body>
<div class='container'>
<div class='header'><h1>실시간 촬영 및 분석</h1></div>
<div class='video-container'><img id='video-stream' crossorigin='anonymous'><canvas id='yolo-overlay' class='overlay-canvas'></canvas></div>
<div class='info-panel'>
<div class='info-panel-header'><h2>정보 및 분석 (거실)</h2><span id='current-time'>로딩 중...</span></div>
<div class='yolo-toggle'><input type='checkbox' id='toggle-yolo'><label for='toggle-yolo'>YOLOv5 감지 표시</label></div>
<div id='analysis-status'>초기화 중...</div>
<div id='analysis-result'></div>
<p class='explanatory-text'>자동 분석이 곧 시작됩니다.</p>
</div>
</div>
<script>
const GEMINI_API_KEY = 'YOUR_GEMINI_API_KEY';
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=' + GEMINI_API_KEY;
let isAnalyzing = false;
let yoloEnabled = false;
let yoloInFlight = false;
let yoloLoopActive = false;
let yoloLastTick = 0;
let yoloFpsEMA = 0;

function updateTime() { const now = new Date(); document.getElementById('current-time').textContent = now.toLocaleTimeString('ko-KR'); }
setInterval(updateTime, 1000); updateTime();
function captureFrame() {
  const video = document.getElementById('video-stream');
  if (!video || !video.naturalWidth || !video.naturalHeight) { return null; }
  const canvas = document.createElement('canvas');
  canvas.width = video.naturalWidth;
  canvas.height = video.naturalHeight;
  const context = canvas.getContext('2d');
  context.drawImage(video, 0, 0, canvas.width, canvas.height);
  return canvas.toDataURL('image/jpeg').split(',')[1];
}
function captureFrameResized(maxEdge = 640, quality = 0.6) {
  const video = document.getElementById('video-stream');
  if (!video || !video.naturalWidth || !video.naturalHeight) { return null; }
  const vw = video.naturalWidth, vh = video.naturalHeight;
  const scale = Math.min(1, maxEdge / Math.max(vw, vh));
  const tw = Math.round(vw * scale);
  const th = Math.round(vh * scale);
  const canvas = document.createElement('canvas');
  canvas.width = tw;
  canvas.height = th;
  const context = canvas.getContext('2d');
  context.drawImage(video, 0, 0, tw, th);
  const dataUrl = canvas.toDataURL('image/jpeg', quality);
  return { b64: dataUrl.split(',')[1], width: tw, height: th, scaleX: vw / tw, scaleY: vh / th };
}
function clearOverlay() {
  const overlay = document.getElementById('yolo-overlay');
  const ctx = overlay.getContext('2d');
  ctx.clearRect(0, 0, overlay.width, overlay.height);
}
function drawDetections(detections, scaleX = 1, scaleY = 1, fps = null) {
  const overlay = document.getElementById('yolo-overlay');
  const video = document.getElementById('video-stream');
  if (!video || !video.naturalWidth || !video.naturalHeight) { return; }
  // Set canvas internal size to the video intrinsic size for 1:1 bbox mapping
  if (overlay.width !== video.naturalWidth || overlay.height !== video.naturalHeight) {
    overlay.width = video.naturalWidth;
    overlay.height = video.naturalHeight;
  }
  const ctx = overlay.getContext('2d');
  ctx.clearRect(0, 0, overlay.width, overlay.height);
  ctx.lineWidth = Math.max(2, Math.round(video.naturalWidth / 400));
  ctx.font = `${Math.max(12, Math.round(video.naturalWidth / 50))}px sans-serif`;
  const counts = {};
  detections.filter(d => (d.confidence == null || d.confidence >= 0.6)).forEach(d => {
    const [bx1, by1, bx2, by2] = d.bbox;
    const x1 = bx1 * scaleX, y1 = by1 * scaleY, x2 = bx2 * scaleX, y2 = by2 * scaleY;
    const w = x2 - x1, h = y2 - y1;
    ctx.strokeStyle = 'rgba(255, 56, 96, 0.95)';
    ctx.fillStyle = 'rgba(255, 56, 96, 0.2)';
    ctx.strokeRect(x1, y1, w, h);
    ctx.fillRect(x1, y1, w, h);
    const label = `${d.label || ''} ${(d.confidence != null ? (d.confidence*100).toFixed(1)+'%' : '')}`.trim();
    if (label) {
      const pad = 4;
      const metrics = ctx.measureText(label);
      const textW = metrics.width + pad*2;
      const textH = Math.max(parseInt(ctx.font, 10) + pad*2, 18);
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(x1, Math.max(0, y1 - textH), textW, textH);
      ctx.fillStyle = '#ffffff';
      ctx.fillText(label, x1 + pad, Math.max(12, y1 - textH/2 + 6));
    }
    const key = (d.label || 'obj');
    counts[key] = (counts[key] || 0) + 1;
  });
  const headerText = `${Object.entries(counts).map(([k,v])=>`${k}:${v}`).join(', ')}` + (fps ? ` | FPS: ${fps.toFixed(1)}` : '');
  if (headerText.trim()) {
    const padH = 6, padW = 8;
    ctx.font = `${Math.max(12, Math.round(video.naturalWidth / 60))}px sans-serif`;
    const width = ctx.measureText(headerText).width + padW*2;
    const height = Math.max(parseInt(ctx.font, 10) + padH*2, 22);
    ctx.fillStyle = 'rgba(0,0,0,0.75)';
    ctx.fillRect(0, 0, Math.min(width, overlay.width), height);
    ctx.fillStyle = '#ffffff';
    ctx.fillText(headerText, padW, Math.floor(height - padH));
  }
}
async function requestYolo(base64Image, scaleX = 1, scaleY = 1) {
  try {
    const res = await fetch('/detect', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ image: base64Image }) });
    if (!res.ok) throw new Error('YOLO 요청 실패: ' + res.status);
    const data = await res.json();
    if (data && Array.isArray(data.detections)) {
      const now = performance.now();
      if (yoloLastTick) {
        const dt = (now - yoloLastTick) / 1000;
        const instFps = dt > 0 ? (1 / dt) : 0;
        yoloFpsEMA = yoloFpsEMA ? (0.85 * yoloFpsEMA + 0.15 * instFps) : instFps;
      }
      yoloLastTick = now;
      drawDetections(data.detections, scaleX, scaleY, yoloFpsEMA || null);
    } else {
      clearOverlay();
    }
  } catch (e) {
    console.log('YOLO 오류:', e);
  }
}
function startYoloLoop() {
  if (yoloLoopActive) return;
  yoloLoopActive = true;
  const tick = () => {
    if (!yoloLoopActive) return;
    if (yoloEnabled && !yoloInFlight) {
      const cap = captureFrameResized(640, 0.5);
      if (cap && cap.b64) {
        yoloInFlight = true;
        requestYolo(cap.b64, cap.scaleX, cap.scaleY).finally(() => { yoloInFlight = false; });
      }
    }
    // Aim ~10-12 FPS; adjust as needed
    setTimeout(() => requestAnimationFrame(tick), 80);
  };
  requestAnimationFrame(tick);
}
function stopYoloLoop() {
  yoloLoopActive = false;
}
async function analyzeImage(base64Image) {
  try {
    const prompt = `환자 위치: 거실.\n` +
      `이미지 속 환자의 행동 및 주요 상황을 분석해주세요.\n` +
      `목표: 이상 행동, 위험 상황(예: 낙상, 화재, 쓰러짐, 배회) 즉시 감지.\n` +
      `분류: 'Abnormal', 'Dangerous', 'Normal' 중 하나로 지정.\n` +
      `설명: 핵심적인 내용만 간결한 한국어로 작성.\n` +
      `경고 메시지: 환자에게 직접 전달할 음성 경고 메시지를 작성. 치매 어르신이 이해하기 쉬운 간단하고 명확한 한국어로 작성.\n` +
      `응답 형식 (JSON만):\n` +
      `{ \"behaviorType\": \"Abnormal\" | \"Dangerous\" | \"Normal\", \"description\": \"핵심 한국어 설명\", \"warningMessage\": \"환자에게 전달할 음성 경고 메시지\" }\n` +
      `참고: 사람 없거나 활동/상황 불명확 시 아래처럼 응답:\n` +
      `{ \"behaviorType\": \"Normal\", \"description\": \"특정 활동/상황 감지 안됨 또는 사람 불명확.\", \"warningMessage\": \"\"}`;
    const response = await fetch(GEMINI_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ parts: [{ text: prompt }, { inline_data: { mime_type: 'image/jpeg', data: base64Image } }] }]
      })
    });
    if (!response.ok) throw new Error(`API 요청 실패: ${response.status}`);
    const data = await response.json();
    if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0]) {
      let textResponse = data.candidates[0].content.parts[0].text.trim();
      if (textResponse.startsWith('```')) { textResponse = textResponse.split('```')[1] || textResponse; }
      textResponse = textResponse.replace('json', '').trim();
      const result = JSON.parse(textResponse);
      fetch('/update_analysis', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(result)
      }).catch(err => console.log('ESP32 업데이트 실패:', err));
      return result;
    }
    return null;
  } catch (error) {
    console.error('분석 중 오류 발생:', error); return null;
  }
}
function updateUI(analysisResult) {
  const resultDiv = document.getElementById('analysis-result');
  resultDiv.innerHTML = '';
  if (!analysisResult || !analysisResult.behaviorType || !analysisResult.description) {
    resultDiv.innerHTML = '<div style="padding:10px;margin:4px 0;border-radius:5px;background-color:#fee2e2;color:#b91c1c;"><strong>오류:</strong> 잘못된 분석 결과 형식입니다.</div>';
    return;
  }
  const msg = document.createElement('div');
  let statusText = '', bgColor = '#f3f4f6', textColor = '#1f2937';
  switch (analysisResult.behaviorType) {
    case 'Dangerous': statusText = '위험 상황'; bgColor = '#fee2e2'; textColor = '#991b1b'; break;
    case 'Abnormal': statusText = '이상 행동'; bgColor = '#fef3c7'; textColor = '#92400e'; break;
    case 'Normal': statusText = '정상'; bgColor = '#d1fae5'; textColor = '#065f46'; break;
  }
  msg.innerHTML = `<strong>분석 결과 (${statusText}):</strong> ${analysisResult.description}`;
  msg.style.background = bgColor;
  msg.style.color = textColor;
  msg.style.padding = '10px';
  msg.style.margin = '4px 0';
  msg.style.borderRadius = '8px';
  resultDiv.appendChild(msg);
}
async function performAnalysis() {
  const statusDiv = document.getElementById('analysis-status');
  if (isAnalyzing) return;
  isAnalyzing = true;
  statusDiv.textContent = '자동 분석 중...';
  const base64Image = captureFrame();
  if (base64Image) {
    try {
      // YOLO handled by its own fast loop; keep overlay cleared if disabled
      if (!yoloEnabled) { clearOverlay(); }
      const result = await analyzeImage(base64Image);
      if (result) {
        if (window.parent) {
          window.parent.postMessage({ type: 'MEMORIA_ANALYSIS_RESULT', payload: { ...result, locationGuess: '거실' } }, '*');
        }
        updateUI(result);
        statusDiv.textContent = '마지막 분석: ' + new Date().toLocaleTimeString('ko-KR');
      } else {
        statusDiv.textContent = '분석 실패. 10초 후 재시도...';
      }
    } catch (error) {
      console.error('분석 중 오류:', error);
      statusDiv.textContent = '오류 발생. 10초 후 재시도...';
    }
  } else {
    statusDiv.textContent = '이미지 캡처 실패. 10초 후 재시도...';
  }
  isAnalyzing = false;
}
window.addEventListener('load', () => {
  document.querySelector('.explanatory-text').textContent = '10초마다 자동으로 화면을 분석하고 있습니다.';
  setTimeout(performAnalysis, 2000);
  setInterval(performAnalysis, 7000);
  const toggle = document.getElementById('toggle-yolo');
  toggle.addEventListener('change', () => {
    yoloEnabled = toggle.checked;
    if (yoloEnabled) {
      clearOverlay();
      startYoloLoop();
    } else {
      clearOverlay();
      stopYoloLoop();
    }
  });
});
// ESP32 스트림 주소를 동적으로 할당
(function() {
  var esp32Host = '{{ esp32_host }}';
  var protocol = location.protocol === 'https:' ? 'https:' : 'http:';
  var streamUrl = protocol + '//' + esp32Host.replace(/^https?:\/\//, '') + ':81/stream';
  document.getElementById('video-stream').src = streamUrl;
})();
</script>
</body></html> 

